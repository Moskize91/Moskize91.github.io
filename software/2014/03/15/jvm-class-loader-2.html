<html lan="zh-cmn-Hans" xmlns="http://www.w3.org/1999/xhtml">
	<head>
		<meta http-equiv="content-type" content="text/html;charset=utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />
		<link rel="stylesheet" href="/mdl-style.css" />
		<script src="/mdl-min.js"></script>
		<link rel="stylesheet" href="/styles.css">
		
			<script type="text/javascript" src="/jquery.min.js"></script>
			<script type="text/javascript" src="/fancybox/jquery.fancybox-1.3.4.pack.js"></script>
			<link rel="stylesheet" href="/fancybox/jquery.fancybox-1.3.4.css" type="text/css" media="screen" />
		
		<title>
			
				JVM类装载机制的解析，以及热更新的探讨（二） - 
			 moskize 的博客
		</title>
	</head>
	<body class="util-centered-container">
    
    <header class="tzy-header">
        <span class="tzy-header__title">
            <a href="/">Moskize's Blog</a>
        </span>
        <div class="tzy-header__elements">
        
          <nav>
              
              <a href="/nodes/technology.html">
                技术
              </a>
              
              <a href="/nodes/chat.html">
                杂谈
              </a>
              
          </nav>
        </div>
        <div style="clear: both;"/>
    </header>
      
    <main class="tzy-content util-centered-content">
	    

<div class="tzy-details">
    
	<div class="card util-centered-container">
        <div class="tzy-details__header">
        	<a href="/" class="mdl-button">返回首页</a>
             
             <div style="clear: both;"/>
        </div>
        
        <div class="tzy-details__content util-centered-content">
        
	    	<div class="tzy-article">
	    		<h1 class="title">JVM类装载机制的解析，以及热更新的探讨（二）</h1>
	    		
	            <p>同样，一个Class对象必须知道自己的超类、超级接口。因此，Class对象会引用自己的超类和超级接口的Class对象。这种引用一定是实例引用。（实际上，超类、超级接口的引用也存储在常量池中，但为了区分依赖类的引用，将它特殊表述一下。）</p>

<p>因此，我暂且得到两条结论。</p>

<ul>
<li><p>结论一：持有一个Class对象的引用，则任何该Class对象直接或间接依赖的所有类（如果被加载了），都不可能被卸载。同样，只要有一个类直接或间接依赖某个类，则该类不可能被卸载。</p></li>
<li><p>结论二：持有一个Class对象的引用，则该类的所有超类、超接口都不能被卸载。同样，如果任何一个类（或接口）存在一个没有被卸载的子类（或实现类、子接口），则该类（接口）不可能被卸载。</p></li>
</ul>

<p>由此可见，对于一个软件而言，其所有class文件可以看做一个从包含main方法的根节点出发，在一张依赖图中搜索所有可达节点，所有可达节点构成的集合。而这个集合中的绝大部分类，要么全部保留在内存中，要么全部卸载。</p>

<p>对于一个模块而言，如果该模块之间的类彼此都存在依赖，则该模块必须整个地被卸载。因此，如果一个应用程序想要利用一个模块卸载另外一个模块。必要条件就是，执行卸载操作的模块必须零依赖被卸载的模块。</p>

<p>零依赖的含义就是，被依赖的模块是完全透明的，是不可见的。</p>

<p>根据上面的结论，卸载必须是以模块为单位。因此，所谓卸载一个强耦合的类是完全不可能的。因此，我可以放弃说“卸载类”，而应该说“卸载模块”。</p>

<p>那么，卸载一个模块的充分条件是什么呢？</p>

<p>回到前面的那张引用关系图，让我们来看看那些其他要素可能引用Class对象。</p>

<p><img src="/public/upload/images/jvm-class-loader-001.png" alt="" /></p>

<p>对于任何一个Java对象而言，它都一定是某个类的实例，因此，它能直接或间接的引用到该类的Class对象。这一推论的理由有三，其一，JVM在将对象进行向下转型、instanceof判定的时候，一定要知道对象的类型，倘若对象无法引用到类的Class对象，这个过程何以进行呢？其二，子类可重写父类的方法，运行时的多态令虚拟机能正确调用到对象方法（防止子类调用到父类被覆盖的方法），如果不知对象类型，何以实现？其三，Object类有一个native方法getClass()可以直接获取对象的类Class对象。</p>

<p>类加载器在加载了一个类之后，当第二次接受到该类的类名之后，加载器会直接返回该类的对象，而不是重复加载该类。虚拟机绝不允许同一个命名空间中的一个类被加载了两次，因此类加载器必须缓存所有它加载的类的Class对象，以供返回。</p>

<p>此外，ClassLoader也好，Class对象也好，这些本身能被变量所引用。如果某些可达的变量（局部变量、成员变量、静态变量）引用了它们，自然也会让整个模块变得可达而无法被卸载。</p>

<p>此外，某些特殊的类加载器永远是可达的，它们是Bootstrap、Extendsion、System。因此，我可以得出一条结论。</p>

<ul>
<li>结论三：Java的标准类库一旦加载，永远不能卸载。</li>
<li>结论四：CLASS_PATH中的类（系统加载器加载的类），一旦加载，永远不能被卸载。</li>
</ul>

<p>因此，一个模块中的所有类必须使用同一个ClassLoader实例加载。而且这个ClassLoader实例不能是Extendsion和System。这个ClassLoader实例的控制权必须掌握在操作卸载的模块那里。随时释放该实例的引用，使ClassLoader变得不可达。</p>

<p>此外，该模块任意类的实例都必须是不可达的，存在任何一个可达的该模块类的实例，模块都无法释放。</p>

<p>至此，我得到了卸载模块的充分条件：模块的全部类由一个可控的ClassLoader加载；释放该模块的定义类加载器引用；释放该模块所有类的实例引用；释放该模块的Class对象引用。</p>

<p>还有，模块的定义类加载器、类实例、Class对象，这些东西，只要没有引用掌握在其他模块那里，也没有掌握在栈内存中，就一定可以卸载模块。特别的，模块自己引用了这些东西，尤其是模块的静态变量引用了这些东西，那是完全不影响卸载的。</p>

<p>有一种观点认为，垃圾回收判断的根节点包括所有类的静态变量，这是错误的。实际上如果一个模块变得不可达了，它的所有的类的静态变量也会变得不可达，并会被回收释放。</p>

	        	</div>
	        </div>
	     </div>
	     
	        
	         	<HR/>
	         	<div class="tzy-details__content util-centered-content">
		         	<div class="tzy-details__comments">
		 	            <!-- Duoshuo Comment BEGIN -->
		 	            <div class="ds-thread"></div>
		                <script type="text/javascript">
		                    var duoshuoQuery = {short_name:"taozeyu"};
		                    (function() {
		                        var ds = document.createElement('script');
		                        ds.type = 'text/javascript';ds.async = true;
		                        ds.src = 'http://static.duoshuo.com/embed.js';
		                        ds.charset = 'UTF-8';
		                        (document.getElementsByTagName('head')[0] 
		                        || document.getElementsByTagName('body')[0]).appendChild(ds);
		                    })();
		                </script>
		 	         </div>
	 	         </div>
	        
    </div>
    <script type="text/javascript">
    	$(".tzy-details img").each(function (){
    		var src = $(this).attr("src"),
    			alt = $(this).attr("alt");
    		
    		var html = ['<a class="fancybox-images" href="', src, '" title="',
    					 alt, '"><img src="', src, '" alt="', alt, '"/></a>'].join("");
    		
    		$(this).after(html);
    		$(this).remove();
    	});
    	$('.tzy-details .fancybox-images').fancybox({
            prevEffect : 'none',
            nextEffect : 'none',

            closeBtn  : true,
            arrows    : true,
            nextClick : true,

            helpers : {
                thumbs : {
                    width  : 50,
                    height : 50
                }
            }
        });
    </script>
</div>

    </main>
    
    <div style="visibility: hidden;">
	    <script type="text/javascript">
	    var _bdhmProtocol = (("https:" == document.location.protocol) ? " https://" : " http://");
	    document.write(unescape("%3Cscript src='" + _bdhmProtocol + "hm.baidu.com/h.js%3F0a70f08f11313ad84ee0ede2b3d7dc60' type='text/javascript'%3E%3C/script%3E"));
	    </script>
    </div>
    
	</body>
</html>
